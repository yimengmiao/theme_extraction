
# 后处理代码设计流程

## 背景
本流程设计基于`prompt2`的输出，旨在构造出主题提取`prompt3`的输入文本。该过程通过分割、索引、合并等步骤对`prompt2`的输出进行后处理，生成符合特定规则的结构化文本，最终输出为`prompt3`的输入格式。

## 处理流程

1. **文本分割**
   - 首先，将`prompt2`的输入文本根据换行符`
`进行分割，得到一个列表`input1_list`。这个列表中的每个元素对应一段完整的文本片段。
   - 例子：
     ```python
     input1_list = prompt2_input.split('\n')
     ```
     输入文本：
     ```python
     发起：老师发起提问1老师讲解内容1老师发起提问2\n回应：学生回答1\n讲解：老师讲解内容2\n讲解：老师讲解内容3\n发起：老师发起提问3老师发起提问4\n回应：学生回答2\n讲解：老师讲解内容4\n讲解：老师讲解内容5
     ```

2. **寻找断点索引**
   - 根据预定义的`breakpoint`列表，遍历`input1_list`，寻找与`breakpoint`列表中元素匹配的索引，将这些索引存储到`list1`中。匹配时忽略文本中的标点符号。
   - 例子：
     ```python
     breakpoint = [
        "讲解:老师讲解内容2",
        "讲解:老师讲解内容3"
     ]
     ```

3. **索引去重**
   - 对于`list1`中的索引进行去重处理，避免重复索引影响后续的处理步骤。
   - 使用字典的方式去重：
     ```python
     list1 = method_dict(list1)
     ```

4. **处理相邻索引**
   - 遍历索引列表`list1`，对于相邻的索引对，只保留较小的索引，生成新的索引列表`list2`。这确保了后续的切分操作不会因相邻的内容被重复处理。
   - 例子：
     ```python
     list2 = filter_consecutive(list1)
     ```

5. **根据索引切分文本**
   - 根据`list2`中的索引，对`input1_list`进行切分，生成若干子列表。每个子列表代表文本的一个片段。
   - 例子：
     ```python
     first_piece = input1_list[0:list2[0]] 
     second_piece = input1_list[list2[0]:list2[1]] 
     third_piece = input1_list[list2[1]:]
     ```

6. **合并相邻的讲解内容**
   - 对每个子列表中的相邻讲解内容进行合并。相邻的“讲解”片段将被合并为一个整体，并且去除重复的“讲解：”前缀。
   - 例子：
     ```python
     '讲解：老师讲解内容2,老师讲解内容3'
     ```

7. **按序列进行分割**
   - 根据四种片段序列（发起-回应-讲解、讲解-发起-回应等），对合并后的子列表进行分割。分割后的每个子列表代表一个完整的师生对话结构。
   - 特殊情况处理：如果`breakpoint`为空，直接将`input1_list`按四种片段序列进行分割。

8. **构造`prompt3`的输入文本**
   - 最后，根据生成的片段，将子列表中的内容拼接成符合`prompt3`输入格式的文本。每个片段都将标记为“师生对话1”、“师生对话2”等。
   - 例子：
     ```python
     prompt3_input = f"师生对话{idx}\n" + "\n".join(segment) + "\n\n"
     ```

## 处理逻辑总结

- 文本经过分割、匹配断点、去重、切分等步骤后，逐步生成结构化的片段列表。
- 片段中的相邻讲解内容被合并，以简化结构。
- 最终的文本输出符合师生对话的层级结构，为`prompt3`的输入提供格式化的内容。

## 特殊情况处理
- 当`breakpoint`为空时，整个`input1_list`将按规则分割，不再依赖索引进行切分。
