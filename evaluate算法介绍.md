
# 最终匹配算法文档

## 1. 概述
本算法旨在通过 **快速匹配** 和 **最长公共子串匹配** 组合的方式，对一组 `predict_items` 和 `labels` 列表中的内容进行高效匹配。算法优先采用快速文本匹配，当快速匹配失败时，进入最长公共子串匹配，以确保在效率与精度之间取得平衡。

## 2. 名词解释

在算法中，有一些核心名词代表不同的数据结构和概念：

- **`predict_item`**：需要进行匹配的目标项，通常是一个字典，包含两个关键字段：
  - **`content`**：要进行匹配的文本内容。
  - **`type`**：文本的类别信息（如“发起”、“评价”、“讲解”，“其它”等）。此字段主要用于分类，不直接参与文本匹配。
  
- **`predict_content_no_punc`**：`predict_item` 中 `content` 字段的处理版本，已去除标点符号，以便提高匹配的准确性。

- **`label`**：人工标注，通常也是字典，包含两个关键字段：
  - **`content`**：参考文本的具体内容，用于与 `predict_item` 进行匹配。
  - **`type`**：文本的类别，与 `predict_item` 的类别类似。

- **`label_content_no_punc`**：`label` 中 `content` 字段的处理版本，已去除标点符号，保证匹配不受标点影响。

## 3. 核心流程

### 3.1 快速匹配
- **目标**：优先进行快速的字符串匹配，通过简单的包含关系来判断 `predict_content_no_punc` 是否可以直接与 `label_content_no_punc` 匹配。
- **流程**：
  1. 对每个 `predict_item`，从 `labels` 列表的 `start_index` 开始，依次取出 `label` 进行匹配。
  2. 判断 `predict_content_no_punc` 是否包含在 `label_content_no_punc` 中：
     - 如果 `True`，则将该 `label` 作为最佳匹配，并立即跳过后续的公共子串匹配。
     - 如果 `False`，则跳出快速匹配，进入公共子串匹配阶段。

  快速匹配通过简单的包含关系进行判断，能够快速过滤出明显的匹配项，减少复杂计算。

### 3.2 最长公共子串匹配
- **目标**：当快速匹配失败时，使用最长公共子串算法来比较 `predict_content_no_punc` 和 `label_content_no_punc` 的相似度。
- **流程**：
  1. 限制公共子串匹配的范围，只在 `labels[start_index:start_index+3]` 的 3 个 `label` 中进行匹配，避免处理整个 `labels` 列表。
  2. 查找两个文本之间的所有公共子串，并计算公共子串的长度占 `predict_content_no_punc` 的比例。
  3. 选择占比最高的公共子串作为匹配依据，并将相应的 `label` 作为最佳匹配。

  最长公共子串匹配用来处理快速匹配失败的情况，通过精确的比较算法找到相似度最高的匹配项。

### 3.3 更新 `start_index`
每次找到最佳匹配后，`start_index` 会更新为当前匹配的索引位置，以确保下一个 `predict_item` 从当前匹配之后的 `label` 开始继续匹配。这样可以减少重复计算，优化性能。

## 4. 使用示例

### 输入数据

#### `labels`：参考文本列表
```python
labels = [
    {"type": "发起", "content": "请袁艺喊“开始上课”，声音要响亮啊。"},
    {"type": "其它", "content": "同学们好，请坐。"},
    {"type": "评价", "content": "真棒。"},
    {"type": "讲解", "content": "昨天呀，我们一起学习了课文八。今天，小猴子呀要到我们班来做客了。"},
    # 更多的label...
]
```

#### `predict_items`：待匹配文本列表
```python
predict_items = [
    {"type": "发起", "content": "请袁艺喊“开始上课”，声音要响亮啊。"},
    {"type": "其它", "content": "同学们好，请坐。"},
    {"type": "评价", "content": "真棒。"},
    {"type": "讲解", "content": "昨天呀，我们一起学习了课文八。今天，小猴子呀要到我们班来做客了。"},
    # 更多的predict...
]
```

### 输出数据

#### 匹配结果
```python
results = [
    {"type": "发起", "content": "请袁艺喊“开始上课”，声音要响亮啊。", "best_match": {"type": "发起", "content": "请袁艺喊“开始上课”，声音要响亮啊。"}},
    {"type": "其它", "content": "同学们好，请坐。", "best_match": {"type": "其它", "content": "同学们好，请坐。"}},
    {"type": "评价", "content": "真棒。", "best_match": {"type": "评价", "content": "真棒。"}},
    {"type": "讲解", "content": "昨天呀，我们一起学习了课文八。今天，小猴子呀要到我们班来做客了。", "best_match": {"type": "讲解", "content": "昨天呀，我们一起学习了课文八。今天，小猴子呀要到我们班来做客了。"}}
]
```

## 5. 算法复杂度
- **时间复杂度**：
  - 快速匹配：每次 `predict_content_no_punc` 与 `label_content_no_punc` 的包含匹配时间复杂度为 `O(n)`，其中 `n` 为文本长度。
  - 公共子串匹配：最长公共子串的时间复杂度为 `O(m * n)`，其中 `m` 和 `n` 分别是两个文本的长度。
  
  由于快速匹配成功后跳过公共子串匹配，并且公共子串匹配的范围被限制在 `start_index:start_index+3`，整体复杂度被有效控制。

## 6. 优化点
- **快速匹配优先**：快速匹配通过简单的包含关系来提升匹配效率，避免冗余计算。
- **公共子串匹配范围限制**：最长公共子串匹配的范围被限制在 `labels[start_index:start_index+3]`，减少了不必要的计算。
- **索引更新**：每次匹配成功后更新 `start_index`，确保后续的匹配从已匹配过的位置继续，避免重复计算。

## 7. 注意事项
- 确保输入文本进行了标点符号的清理，避免因标点符号影响匹配结果。
- 可以根据实际情况调整公共子串匹配的阈值（当前设置为 30%）。
